1. mybatis
2. jpa
3. 공통 내용 -> 토큰등 총괄
	3.1 dto와 엔티티 그외 data 담는 것들
		3.1.0 **동일하게 [행] -> [테이블에 반영(쿼리)]로 보면된다.** -> 테이블과 행을 머리가 그리고, 테이블 구성은 일단 객체를 표현하면된다.(같은 도메인과 나머지)
		3.1.1 dto vs map 사용하기.
		3.1.2 dto, map등 data 담는 것들을 비슷한 도메인과 자주 쓰이는 건 한곳에 묶을 수 있다.
			<같은 도메인이니깐 같이 묶어버리고, 요청되는데 같이 붙어다니네..? 그러면 같은 테이블에 묶어버릴수 있다. 또한 이를 통해 비교하고 사용자 체크해야하니  토큰은 서버에 저장되어야 한다.>
		3.1.3 dto vs map 사용하기.
		3.1.4 
	3.2 Optional -> 
	3.3 Stream -> 
	
-------------------------
1. 

-------------------------
2. 
	2.1 
	2.2 
	2.3 jpa에서 진행하는 방법




2.3
어떻게 하든지 entity를 거쳐서 repository에 반영.
	Repository: Entity를 필수로 가진다. (interface로 선언해서 extends 상속받는 작업이 필수)
	entity:	Entity로 "table의 스키마랑 행들"을 프로그래밍 영역에서 다룬다.
			entity를 수정하면서 또는 생성하면서 만들어진다. repository는 table로 접근하고, 조작할 수 있는 걸로 생각하면 편하다.
			=> 알아서 관리해준다. .save()로 entity(행)을 넣어주면~!

		=> 한번에 처리할 수도 있을 것 같으나, 일단 기본적으로 하나의 entity만 생각하자.

	findBy~
		그외에 커스터마이징할 수 있다. (*코드가 늘어나는 시점을 잘 생각해보는게 중요*)





-------------------------
3. 

3.1 dto와 엔티티 그외 data 담는 것들

<조회시만 이용하고, delete라던지 그런것들은 일단 deleteById를 통해서 진행한다. 하지만 실무에서는 논리 삭제를 이용하는 편이다.
3.1.0 **동일하게 행 -> 테이블(쿼리)로 보면된다.**
(일단 행에 해당하는 걸로 dto를 썻다.)
mybatis도 일단 행을 토대로 이뤄진다. 행이 없을 순 있지만, 있다면, 해당 순서로 이뤄진다.
ex) 생성과 수정등은 행에 대해 추가되거나 수정된다. 이를 테이블에 반영(쿼리)되어야한다.
jpa는 굳이 추가로 엔티티 활용해야하니 엔티티를 생성하고, 해당값은 map이나 dto를 값을 활용하여 넣는다. 해당 값은 테이블 즉 repository를 이용하는데, 반영(쿼리)되도록한다. -> jpa에서는 .save를 활용하면 그냥된다.

ex) 로그인은? 

우선 정의할때 id랑 pw면, 일단 지금 너무 dto에 있는거랑 내용이 다르니, map으로 처리해보고자 한다.
(안하는게 좋긴한데, 또는 유효성 검증을 하거나 등등 추가로 해주거나 필요할 수 있음.)
@RequesBody로 받아서 진행한다. 그러면, 해당값은 행에 대한 내용이다.
이를 체크하고, 맞으면 오케이 싸인을 보내주면 됐었는데, 토큰을 생성하고 보내줘야하니 이를 대신한다.
또는 ResponseEntity에 담아서 보내준다.(이 방법이 더 일반적이다.)
여튼 일단 보내고 (service에) 해당 코드에서는 일단 검증등 과정을 거친후, 
일단 해당 id랑 pw가 있는지 검사만 하면된다. 	테이블에서 select 구문을 이용해서 값이 잇는지 검토
					테이블 반영도 마찬가지임.(일단 해당 과정을 거친다.) -> 
일단 jpa면 map 기준으로 일단엔티티는 필요가 없을듯하다. 수정과 생성시에 있으면 된다. -> 행을 수정하거나 생성하는 경우 엔티티랑 save를 이용하면된다. 
.orElseThrows로 NPE를회피했고, 

일단 entity를 중점적으로 활용하거나 그냥 boolean으로 보는게 편하다.(행기준으로)
해당 JpaSampleEntity를 받아왔으면 다음 코드를 실행할 수 있으므로, 일단 불러왔다는 가정하에 진행할 수 있다.
해당값과 같은 도메인에 넣어줬으므로, 해당 엔티티에서 set으로 처리해버릴 수 있다.(근데 실무에서 set하고 검증하는 과정이 필수적.)
행을 수정하고, 반영시킨다. save시키면된다.(행을 토대로 진행 -> 일단 암기된 방식토대로 하다가 쓰지 않으면 지워버린다.)



3.1.1 dto vs map 사용하기.
dto를 통해서 데이터를 가져오는데, 우선 table 명세서를 작성하고, 비지니스 로직을 정의해야된다. (여기서 필요한 전달받는 데이터 파악한다.)
-> dto의 getter와 setter를 활용해서 주고 받는다. 
-> 간단한 로직은 Map을 통해서 주고 받는다.

3.1.2 dto, map등 data 담는 것들을 비슷한 도메인과 자주 쓰이는 건 한곳에 묶을 수 있다.

[도메인이 비슷한 것 끼리 묶어서]
// -> 이렇게 같이 넣어서 처리할 수 있구나, 도메인이 비슷한 것 끼리 묶어서 처리해볼 수 있다.
// 다만, 사용하지 않는 것은 최대한 지향해야한다.


// 같은 도메인이니깐 같이 묶어버리고, 요청되는데 같이 붙어다니네..? 그러면 같은 테이블에 묶어버릴수 있다. 또한 이를 통해 비교하고 사용자 체크해야하니  토큰은 서버에 저장되어야 한다.
// 우선 예를 들면 token도 함께 담을 수 있다. (일단 해당 부분은 table의 행에 해당한다.)
// 그렇다보니, 로그인시, 토큰을 생성하고, 토큰을 담는 컬럼 존재 테이블(jpa를 쓰고 있다면 해당 jpa)에 넣어두고, 토큰 만료 및 갱신등 체크해서 인증과 인가를 진행할 수 있다. 




3.2 jpa에서 optional을 사용한다.
	isPresent(), isElse(), orElseThrow()
	.get()으로 풀어쓴다.


// ctrl에서 header에 있는 token을 가져와서 subString으로 Bearer를 제외한 token을 가져온다.(= refresh token임.)
    // service에서 token을 검증하고(1), 유효한 경우 refresh token을 갱신하고, 새로운 JWT Access Token을 생성한다.(2)
    // (1) token을 검증하는 방법은, op.isPresent()으로 체크 -> 만약 유효하지 않으면, 예외가 발생한다.
    // (2) 새로운 JWT Access Token을 생성하는 방법은, jwtProvider에서 generateAccToken(email)으로 생성한다.


eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIganNkc2RAc3NzcyIsImlhdCI6MTc0NTk4MjkxMywiZXhwIjoxNzQ1OTg2NTEzfQ.jx_764Z5KQPhaWWLLAAuwxaWT--dnGrItnRvIEhU7gs



accessToken -. 배열로 내려온다.(다만 response.data.~로 받는 경우는 `Barear ${}`를 체크해줘야한다.)
refreshToken -> 값만 내려온다 -> r그렇기 때문에 배열에 담아줘야한다.


3.3 

-------------------------



