# contents-1.14 [실습 내용](https://colab.research.google.com/drive/1Wsa1Je5o_7jNb5LRsE9a7c0ND8Qb__d4#scrollTo=vjw0IKz1so4D)


인터프리터 vs 컴파일: type 관점
source.file -> compile -> byte code -> runtime -> exec

: 데이터를 담는 동사적인 의미
: 데이터를 가지고하는 행위

함수(ㅇ) vs 메소드(x): **단독**으로 실행 가능 여부

*tip* 
- :int와 같이 최근 문법을 추천하지 않는다. 하지만, 익혀두는건 필요하다...(명세서 지침을 바꿀수 있는 위치가 된다면 가능)
- **type을 체크하고 쓸 수 있어야 확실하게 접근할 수 있다.**

## 에러항목

### concatenate 에러(str)

<img src="https://github.com/user-attachments/assets/0f14454b-f3bf-45ea-b0cd-75c11bfc4d59" width="300" height="300" alt="이미지 설명">

### dictionary : mapping이니깐 인덱싱과 슬라이싱이 리스트와 동일한 방식으론 불가능하다.
key는 항상 string으로 불러서 쓴다.


<img src="https://github.com/user-attachments/assets/38514bcf-8577-4f87-a526-5c1a0def5f93" width="300" height="200" alt="이미지 설명">

### tuple : sequence(순서)이니깐 인덱싱과 슬라이싱이 리스트와 동일한 방식으로 가능하다. -> 무조건 []로 숫자값을 토대로 사용은 확실히 가능


### string : sequence(순서)이니깐 인덱싱과 슬라이싱이 리스트와 동일한 방식으로 가능하다. -> 무조건 []로 숫자값을 토대로 사용은 확실히 가능



### list : sequence이니깐 인덱싱과 슬라이싱이 리스트와 동일한 방식으로 가능하다. -> 무조건 []로 숫자값을 토대로 사용은 확실히 가능
[start: end: step]




# contents-1.15 [실습 내용](https://colab.research.google.com/drive/1Wsa1Je5o_7jNb5LRsE9a7c0ND8Qb__d4#scrollTo=vjw0IKz1so4D)
oop: object oriented programming

python: function 기반 oop
java: class 기반 oop



object --> class --> instance(프로그래밍상)


* class: instance를 만들기 위한 template
- **명사적: 변수**
- **동사적: 함수**


문자열 함수 

#### 문자열 수정할 때, 사용한다. 다만, 공통적 제거하고 싶은 문자열은 자주 쓰이니 함수로 만들어졌다. 여기선 공백.
- strip() # 공백 제거
  - lstrip()
  - rstrip()

#### 
- find # 해당 문자열 해당하는 인덱스번호 찾기

#### 끝 문자열(확장자)에 관심이 있으면 해당 메소드 이용 가능 -> 인덱스로 알 수 없거나 인덱스 사용하면 복잡한 경우 추천. 
- endswith()
feat. startwith()도 있다.

#### 열거형등 모인 그룹을 가진 리스트에서 포함 여부 상황에서 조건 판단!
- in, not in



### 대용량의 데이터를 다루기 위한 중요한 변수타입은 list
순서, 중복, 수정, 삭제 가능
#### append - 최소 arg 1개
#### insert - 최소 arg 2개
#### pop - 최소 arg 1개
#### 

##### index - 최소 arg 1개


=> 그러면 링크드 리스트랑 딕셔너리 자료 구조 체크
1. #### 링크드리스트
**삭제가 많은 상황에서 유용하다.** (노드 간 링크만 수정하면 되기 때문입니다)
리스트랑 딕셔너리보다는 디스크에 저장 부담이 줄어든다.
**연속적 공간 사용이 생각보다 중요하다.**

**검색과 조회는 O(n) 시간복잡도를 가집니다. 배열과 달리 연속된 메모리 공간을 사용하지 않아 캐시 효율성이 떨어질 수 있습니다**
```paintext
- 검색: 링크를 통해 검색을 하기 때문에 원하는 결과가 나올 때까지 찾는다.(배열과 동일하게 일단 해당 기본 블럭만큼 건너뛴다. 다만 링크가 걸릴수도?)
- 조회: 링크를 통해 조회를 하기 때문에 원하는 결과가 나올 때까지 찾는다.(배열과 동일하게 일단 해당 기본 블럭만큼 건너뛴다. 다만 링크가 걸릴수도?)
```

- 수정: 수정하는데, 해당 과정도 리스트랑 동일하다.

- *삭제: 삭제하고 나서 다른 것들은 그냥 링크만 연결해주면 된다.

2. #### 리스트
**연속적 공간 사용이 생각보다 중요하다.**
- 검색
- 조회
- 수정
- 삭제

**간단한 데이터 저장 및 관리**
```paintext
순서가 중요한 데이터 저장: 리스트는 요소들의 순서를 유지하므로, 순서가 중요한 데이터를 다룰 때 유용합니다1.
다양한 타입의 데이터 저장: 리스트는 여러 타입의 데이터를 함께 저장할 수 있어 유연성이 높습니다2.
간단한 데이터 구조가 필요한 경우: 복잡한 관계나 구조가 필요하지 않은 간단한 데이터 저장에 적합합니다
```
**간단한 데이터 저장 및 관리**
```paintext
순서가 중요한 데이터 저장: 리스트는 요소들의 순서를 유지하므로, 순서가 중요한 데이터를 다룰 때 유용합니다1.
다양한 타입의 데이터 저장: 리스트는 여러 타입의 데이터를 함께 저장할 수 있어 유연성이 높습니다2.
간단한 데이터 구조가 필요한 경우: 복잡한 관계나 구조가 필요하지 않은 간단한 데이터 저장에 적합합니다
```


3. #### 딕셔너리
*조회할 때 빠르게 찾을 수 있다.
다만, 메모리 디스크 용량을 많이 요구한다.(그래서 느리다. 삭제랑 수정에 불리함.) 

**--> 메모리/디스크 용량을 많이 요구해서 느리다는 설명은 정확하지 않습니다. (디스크 용량을 많이 가지긴함)**
**--> 해시 테이블 기반으로 평균 O(1) 시간복잡도로 검색, 삽입, 삭제가 가능합니다.**
*검색 중심으로 할 때 유용하다.

- *검색: 인덱스에 해당하는 key를 알고 있기 때문에 빠르다.
- !조회: 인덱스에 해당하는 key를 알고 있기 때문에 빠르다.
- 수정: key를 토대로 수정하긴하지만, 리스트랑 비슷하지만 조금 더 느린걸로..
- 삭제: key, value 둘다 삭제하므로, 느리다.

4. #### 트리
  관계를 살펴본다. 그리고 분리한 설계 가능
  *탐색(조회)에서 많이 쓴다.
  **계층적 데이터 구조를 표현하는 데 유용합니다**

5. #### 그래프
  트리의 일반화된 자료구조이다.
  
6. #### 튜플
  중복제거 & 순서 중요한 경우
  **중복 제거(또는 집합)** 또는 immutable하다.(순서를 가짐) - 확실하게 **순서**가 중요한 경우 사용!
  **리스트보다 메모리 효율적이고 접근 속도가 빠릅니다**

```paintext
[요약]

데이터 *삽입/삭제*가 빈번한 경우: 링크드 리스트
빠른 *검색/조회*가 필요한 경우: 딕셔너리(해쉬테이블을 이용하면 삽입, 삭제도 빠르다고 함)
계층적 데이터 구조: 트리
복잡한 관계 표현: 그래프
'불변성'이 필요하고 메모리 효율성이 중요한 경우: 튜플


```


# contents-1.16 [실습 내용](https://colab.research.google.com/drive/1Wsa1Je5o_7jNb5LRsE9a7c0ND8Qb__d4#scrollTo=vjw0IKz1so4D)


[튜플 자료구조 참고](https://github.com/davJ-star/siat/edit/main/contents.md#%ED%8A%9C%ED%94%8C)

```paintext
 체크~!
```


