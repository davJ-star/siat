// contents-1.14
[실습 내용](https://colab.research.google.com/drive/1Wsa1Je5o_7jNb5LRsE9a7c0ND8Qb__d4#scrollTo=vjw0IKz1so4D)


인터프리터 vs 컴파일: type 관점
source.file -> compile -> byte code -> runtime -> exec

: 데이터를 담는 동사적인 의미
: 데이터를 가지고하는 행위

함수(ㅇ) vs 메소드(x): **단독**으로 실행 가능 여부

*tip* 
- :int와 같이 최근 문법을 추천하지 않는다. 하지만, 익혀두는건 필요하다...(명세서 지침을 바꿀수 있는 위치가 된다면 가능)
- **type을 체크하고 쓸 수 있어야 확실하게 접근할 수 있다.**

## 에러항목

### concatenate 에러(str)

<img src="https://github.com/user-attachments/assets/0f14454b-f3bf-45ea-b0cd-75c11bfc4d59" width="300" height="300" alt="이미지 설명">

### dictionary : mapping이니깐 인덱싱과 슬라이싱이 리스트와 동일한 방식으론 불가능하다.
key는 항상 string으로 불러서 쓴다.


<img src="https://github.com/user-attachments/assets/38514bcf-8577-4f87-a526-5c1a0def5f93" width="300" height="200" alt="이미지 설명">

### tuple : sequence(순서)이니깐 인덱싱과 슬라이싱이 리스트와 동일한 방식으로 가능하다. -> 무조건 []로 숫자값을 토대로 사용은 확실히 가능


### string : sequence(순서)이니깐 인덱싱과 슬라이싱이 리스트와 동일한 방식으로 가능하다. -> 무조건 []로 숫자값을 토대로 사용은 확실히 가능



### list : sequence이니깐 인덱싱과 슬라이싱이 리스트와 동일한 방식으로 가능하다. -> 무조건 []로 숫자값을 토대로 사용은 확실히 가능
[start: end: step]




// contents-1.15
oop: object oriented programming

python: function 기반 oop
java: class 기반 oop



object --> class --> instance(프로그래밍상)


* class: instance를 만들기 위한 template
- **명사적: 변수**
- **동사적: 함수**


문자열 함수 

#### 문자열 수정할 때, 사용한다. 다만, 공통적 제거하고 싶은 문자열은 자주 쓰이니 함수로 만들어졌다. 여기선 공백.
- strip() # 공백 제거
  - lstrip()
  - rstrip()

#### 
- find # 해당 문자열 해당하는 인덱스번호 찾기

#### 끝 문자열(확장자)에 관심이 있으면 해당 메소드 이용 가능 -> 인덱스로 알 수 없거나 인덱스 사용하면 복잡한 경우 추천. 
- endswith()
feat. startwith()도 있다.

#### 열거형등 모인 그룹을 가진 리스트에서 포함 여부 상황에서 조건 판단!
- in, not in



### 대용량의 데이터를 다루기 위한 중요한 변수타입은 list
순서, 중복, 수정, 삭제 가능
#### append - 최소 arg 1개
#### insert - 최소 arg 2개
#### pop - 최소 arg 1개
#### 

##### index - 최소 arg 1개


=> 그러면 링크드 리스트랑 딕셔너리 자료 구조 체크
링크드리스트
삭제가 많은 상황에서 유용하다.
리스트랑 딕셔너리보다는 디스크에 저장 제한이 없다.
- 검색: 링크를 통해 검색을 하기 때문에 원하는 결과가 나올 때까지 찾는다.(배열과 동일하게 일단 해당 기본 블럭만큼 건너뛴다. 다만 링크가 걸릴수도?)
- 조회: 링크를 통해 조회를 하기 때문에 원하는 결과가 나올 때까지 찾는다.(배열과 동일하게 일단 해당 기본 블럭만큼 건너뛴다. 다만 링크가 걸릴수도?)
- 수정: 수정하는데, 해당 과정도 리스트랑 동일하다.
- *삭제: 삭제하고 나서 다른 것들은 그냥 링크만 연결해주면 된다.

리스트
- 검색
- 조회
- 수정
- 삭제

딕셔너리
*조회할 때 빠르게 찾을 수 있다.
다만, 메모리 디스크 용량을 많이 요구한다.(그래서 느리다. 삭제랑 수정에 불리함.)
*검색 중심으로 할 때 유용하다.

- *검색: 인덱스에 해당하는 key를 알고 있기 때문에 빠르다.
- !조회: 인덱스에 해당하는 key를 알고 있기 때문에 빠르다.
- 수정: key를 토대로 수정하긴하지만, 리스트랑 비슷하지만 조금 더 느린걸로..
- 삭제: key, value 둘다 삭제하므로, 느리다.

트리
  관계를 살펴본다. 그리고 분리한 설계 가능
  *탐색(조회)에서 많이 쓴다.

그래프
  트리의 일반화된 자료구조이다.
  
튜플
  중복제거 & 순서 중요한 경우
  중복 제거 또는 immutable하다.(순서를 가짐) - 확실하게 순서가 중요한 경우 사용!

